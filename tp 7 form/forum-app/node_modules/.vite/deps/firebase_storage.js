import { B as isCloudWorkstation, D as FirebaseError, L as getModularInstance, P as getDefaultEmulatorHostnameAndPort, Q as updateEmulatorBanner, T as Component, Y as pingServer, c as _getProvider, f as _registerComponent, g as getApp, k as createMockUserToken, n as SDK_VERSION, u as _isFirebaseServerApp, x as registerVersion } from "./index.esm-CXdVKVoA.js";

//#region node_modules/@firebase/storage/dist/index.esm.js
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @fileoverview Constants used in the Firebase Storage library.
*/
/**
* Domain name for firebase storage.
*/
var DEFAULT_HOST = "firebasestorage.googleapis.com";
/**
* The key in Firebase config json for the storage bucket.
*/
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
/**
* 2 minutes
*
* The timeout for all operations except upload.
*/
var DEFAULT_MAX_OPERATION_RETRY_TIME = 120 * 1e3;
/**
* 10 minutes
*
* The timeout for upload.
*/
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 600 * 1e3;
/**
* 1 second
*/
var DEFAULT_MIN_SLEEP_TIME_MILLIS = 1e3;
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* An error returned by the Firebase Storage SDK.
* @public
*/
var StorageError = class StorageError extends FirebaseError {
	/**
	* @param code - A `StorageErrorCode` string to be prefixed with 'storage/' and
	*  added to the end of the message.
	* @param message  - Error message.
	* @param status_ - Corresponding HTTP Status Code
	*/
	constructor(code, message, status_ = 0) {
		super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);
		this.status_ = status_;
		/**
		* Stores custom error data unique to the `StorageError`.
		*/
		this.customData = { serverResponse: null };
		this._baseMessage = this.message;
		Object.setPrototypeOf(this, StorageError.prototype);
	}
	get status() {
		return this.status_;
	}
	set status(status) {
		this.status_ = status;
	}
	/**
	* Compares a `StorageErrorCode` against this error's code, filtering out the prefix.
	*/
	_codeEquals(code) {
		return prependCode(code) === this.code;
	}
	/**
	* Optional response message that was added by the server.
	*/
	get serverResponse() {
		return this.customData.serverResponse;
	}
	set serverResponse(serverResponse) {
		this.customData.serverResponse = serverResponse;
		if (this.customData.serverResponse) this.message = `${this._baseMessage}\n${this.customData.serverResponse}`;
		else this.message = this._baseMessage;
	}
};
/**
* @public
* Error codes that can be attached to `StorageError` objects.
*/
var StorageErrorCode;
(function(StorageErrorCode$1) {
	StorageErrorCode$1["UNKNOWN"] = "unknown";
	StorageErrorCode$1["OBJECT_NOT_FOUND"] = "object-not-found";
	StorageErrorCode$1["BUCKET_NOT_FOUND"] = "bucket-not-found";
	StorageErrorCode$1["PROJECT_NOT_FOUND"] = "project-not-found";
	StorageErrorCode$1["QUOTA_EXCEEDED"] = "quota-exceeded";
	StorageErrorCode$1["UNAUTHENTICATED"] = "unauthenticated";
	StorageErrorCode$1["UNAUTHORIZED"] = "unauthorized";
	StorageErrorCode$1["UNAUTHORIZED_APP"] = "unauthorized-app";
	StorageErrorCode$1["RETRY_LIMIT_EXCEEDED"] = "retry-limit-exceeded";
	StorageErrorCode$1["INVALID_CHECKSUM"] = "invalid-checksum";
	StorageErrorCode$1["CANCELED"] = "canceled";
	StorageErrorCode$1["INVALID_EVENT_NAME"] = "invalid-event-name";
	StorageErrorCode$1["INVALID_URL"] = "invalid-url";
	StorageErrorCode$1["INVALID_DEFAULT_BUCKET"] = "invalid-default-bucket";
	StorageErrorCode$1["NO_DEFAULT_BUCKET"] = "no-default-bucket";
	StorageErrorCode$1["CANNOT_SLICE_BLOB"] = "cannot-slice-blob";
	StorageErrorCode$1["SERVER_FILE_WRONG_SIZE"] = "server-file-wrong-size";
	StorageErrorCode$1["NO_DOWNLOAD_URL"] = "no-download-url";
	StorageErrorCode$1["INVALID_ARGUMENT"] = "invalid-argument";
	StorageErrorCode$1["INVALID_ARGUMENT_COUNT"] = "invalid-argument-count";
	StorageErrorCode$1["APP_DELETED"] = "app-deleted";
	StorageErrorCode$1["INVALID_ROOT_OPERATION"] = "invalid-root-operation";
	StorageErrorCode$1["INVALID_FORMAT"] = "invalid-format";
	StorageErrorCode$1["INTERNAL_ERROR"] = "internal-error";
	StorageErrorCode$1["UNSUPPORTED_ENVIRONMENT"] = "unsupported-environment";
})(StorageErrorCode || (StorageErrorCode = {}));
function prependCode(code) {
	return "storage/" + code;
}
function unknown() {
	return new StorageError(StorageErrorCode.UNKNOWN, "An unknown error occurred, please check the error payload for server response.");
}
function objectNotFound(path) {
	return new StorageError(StorageErrorCode.OBJECT_NOT_FOUND, "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
	return new StorageError(StorageErrorCode.QUOTA_EXCEEDED, "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
	return new StorageError(StorageErrorCode.UNAUTHENTICATED, "User is not authenticated, please authenticate using Firebase Authentication and try again.");
}
function unauthorizedApp() {
	return new StorageError(StorageErrorCode.UNAUTHORIZED_APP, "This app does not have permission to access Firebase Storage on this project.");
}
function unauthorized(path) {
	return new StorageError(StorageErrorCode.UNAUTHORIZED, "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
	return new StorageError(StorageErrorCode.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.");
}
function canceled() {
	return new StorageError(StorageErrorCode.CANCELED, "User canceled the upload/download.");
}
function invalidUrl(url) {
	return new StorageError(StorageErrorCode.INVALID_URL, "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
	return new StorageError(StorageErrorCode.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
	return new StorageError(StorageErrorCode.NO_DEFAULT_BUCKET, "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function cannotSliceBlob() {
	return new StorageError(StorageErrorCode.CANNOT_SLICE_BLOB, "Cannot slice blob for upload. Please retry the upload.");
}
function serverFileWrongSize() {
	return new StorageError(StorageErrorCode.SERVER_FILE_WRONG_SIZE, "Server recorded incorrect upload file size, please retry the upload.");
}
function noDownloadURL() {
	return new StorageError(StorageErrorCode.NO_DOWNLOAD_URL, "The given file does not have any download URLs.");
}
function missingPolyFill(polyFill) {
	return new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, `${polyFill} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`);
}
/**
* @internal
*/
function invalidArgument(message) {
	return new StorageError(StorageErrorCode.INVALID_ARGUMENT, message);
}
function appDeleted() {
	return new StorageError(StorageErrorCode.APP_DELETED, "The Firebase app was deleted.");
}
/**
* @param name - The name of the operation that was invalid.
*
* @internal
*/
function invalidRootOperation(name$1) {
	return new StorageError(StorageErrorCode.INVALID_ROOT_OPERATION, "The operation '" + name$1 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
/**
* @param format - The format that was not valid.
* @param message - A message describing the format violation.
*/
function invalidFormat(format, message) {
	return new StorageError(StorageErrorCode.INVALID_FORMAT, "String does not match format '" + format + "': " + message);
}
/**
* @param message - A message describing the internal error.
*/
function internalError(message) {
	throw new StorageError(StorageErrorCode.INTERNAL_ERROR, "Internal error: " + message);
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Firebase Storage location data.
*
* @internal
*/
var Location = class Location {
	constructor(bucket, path) {
		this.bucket = bucket;
		this.path_ = path;
	}
	get path() {
		return this.path_;
	}
	get isRoot() {
		return this.path.length === 0;
	}
	fullServerUrl() {
		const encode = encodeURIComponent;
		return "/b/" + encode(this.bucket) + "/o/" + encode(this.path);
	}
	bucketOnlyServerUrl() {
		return "/b/" + encodeURIComponent(this.bucket) + "/o";
	}
	static makeFromBucketSpec(bucketString, host) {
		let bucketLocation;
		try {
			bucketLocation = Location.makeFromUrl(bucketString, host);
		} catch (e) {
			return new Location(bucketString, "");
		}
		if (bucketLocation.path === "") return bucketLocation;
		else throw invalidDefaultBucket(bucketString);
	}
	static makeFromUrl(url, host) {
		let location = null;
		const bucketDomain = "([A-Za-z0-9.\\-_]+)";
		function gsModify(loc) {
			if (loc.path.charAt(loc.path.length - 1) === "/") loc.path_ = loc.path_.slice(0, -1);
		}
		const gsRegex = new RegExp("^gs://" + bucketDomain + "(/(.*))?$", "i");
		const gsIndices = {
			bucket: 1,
			path: 3
		};
		function httpModify(loc) {
			loc.path_ = decodeURIComponent(loc.path);
		}
		const version$1 = "v[A-Za-z0-9_]+";
		const firebaseStorageHost = host.replace(/[.]/g, "\\.");
		const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version$1}/b/${bucketDomain}/o(/([^?#]*).*)?\$`, "i");
		const firebaseStorageIndices = {
			bucket: 1,
			path: 3
		};
		const cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
		const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/([^?#]*)`, "i");
		const groups = [
			{
				regex: gsRegex,
				indices: gsIndices,
				postModify: gsModify
			},
			{
				regex: firebaseStorageRegExp,
				indices: firebaseStorageIndices,
				postModify: httpModify
			},
			{
				regex: cloudStorageRegExp,
				indices: {
					bucket: 1,
					path: 2
				},
				postModify: httpModify
			}
		];
		for (let i = 0; i < groups.length; i++) {
			const group = groups[i];
			const captures = group.regex.exec(url);
			if (captures) {
				const bucketValue = captures[group.indices.bucket];
				let pathValue = captures[group.indices.path];
				if (!pathValue) pathValue = "";
				location = new Location(bucketValue, pathValue);
				group.postModify(location);
				break;
			}
		}
		if (location == null) throw invalidUrl(url);
		return location;
	}
};
/**
* A request whose promise always fails.
*/
var FailRequest = class {
	constructor(error) {
		this.promise_ = Promise.reject(error);
	}
	/** @inheritDoc */
	getPromise() {
		return this.promise_;
	}
	/** @inheritDoc */
	cancel(_appDelete = false) {}
};
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Accepts a callback for an action to perform (`doRequest`),
* and then a callback for when the backoff has completed (`backoffCompleteCb`).
* The callback sent to start requires an argument to call (`onRequestComplete`).
* When `start` calls `doRequest`, it passes a callback for when the request has
* completed, `onRequestComplete`. Based on this, the backoff continues, with
* another call to `doRequest` and the above loop continues until the timeout
* is hit, or a successful response occurs.
* @description
* @param doRequest Callback to perform request
* @param backoffCompleteCb Callback to call when backoff has been completed
*/
function start(doRequest, backoffCompleteCb, timeout) {
	let waitSeconds = 1;
	let retryTimeoutId = null;
	let globalTimeoutId = null;
	let hitTimeout = false;
	let cancelState = 0;
	function canceled$1() {
		return cancelState === 2;
	}
	let triggeredCallback = false;
	function triggerCallback(...args) {
		if (!triggeredCallback) {
			triggeredCallback = true;
			backoffCompleteCb.apply(null, args);
		}
	}
	function callWithDelay(millis) {
		retryTimeoutId = setTimeout(() => {
			retryTimeoutId = null;
			doRequest(responseHandler, canceled$1());
		}, millis);
	}
	function clearGlobalTimeout() {
		if (globalTimeoutId) clearTimeout(globalTimeoutId);
	}
	function responseHandler(success, ...args) {
		if (triggeredCallback) {
			clearGlobalTimeout();
			return;
		}
		if (success) {
			clearGlobalTimeout();
			triggerCallback.call(null, success, ...args);
			return;
		}
		if (canceled$1() || hitTimeout) {
			clearGlobalTimeout();
			triggerCallback.call(null, success, ...args);
			return;
		}
		if (waitSeconds < 64) waitSeconds *= 2;
		let waitMillis;
		if (cancelState === 1) {
			cancelState = 2;
			waitMillis = 0;
		} else waitMillis = (waitSeconds + Math.random()) * 1e3;
		callWithDelay(waitMillis);
	}
	let stopped = false;
	function stop$1(wasTimeout) {
		if (stopped) return;
		stopped = true;
		clearGlobalTimeout();
		if (triggeredCallback) return;
		if (retryTimeoutId !== null) {
			if (!wasTimeout) cancelState = 2;
			clearTimeout(retryTimeoutId);
			callWithDelay(0);
		} else if (!wasTimeout) cancelState = 1;
	}
	callWithDelay(0);
	globalTimeoutId = setTimeout(() => {
		hitTimeout = true;
		stop$1(true);
	}, timeout);
	return stop$1;
}
/**
* Stops the retry loop from repeating.
* If the function is currently "in between" retries, it is invoked immediately
* with the second parameter as "true". Otherwise, it will be invoked once more
* after the current invocation finishes iff the current invocation would have
* triggered another retry.
*/
function stop(id) {
	id(false);
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
function isJustDef(p) {
	return p !== void 0;
}
function isFunction(p) {
	return typeof p === "function";
}
function isNonArrayObject(p) {
	return typeof p === "object" && !Array.isArray(p);
}
function isString(p) {
	return typeof p === "string" || p instanceof String;
}
function isNativeBlob(p) {
	return isNativeBlobDefined() && p instanceof Blob;
}
function isNativeBlobDefined() {
	return typeof Blob !== "undefined";
}
function validateNumber(argument, minValue, maxValue, value) {
	if (value < minValue) throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);
	if (value > maxValue) throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
function makeUrl(urlPart, host, protocol) {
	let origin = host;
	if (protocol == null) origin = `https://${host}`;
	return `${protocol}://${origin}/v0${urlPart}`;
}
function makeQueryString(params) {
	const encode = encodeURIComponent;
	let queryPart = "?";
	for (const key in params) if (params.hasOwnProperty(key)) {
		const nextPart = encode(key) + "=" + encode(params[key]);
		queryPart = queryPart + nextPart + "&";
	}
	queryPart = queryPart.slice(0, -1);
	return queryPart;
}
/**
* Error codes for requests made by the XhrIo wrapper.
*/
var ErrorCode;
(function(ErrorCode$1) {
	ErrorCode$1[ErrorCode$1["NO_ERROR"] = 0] = "NO_ERROR";
	ErrorCode$1[ErrorCode$1["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
	ErrorCode$1[ErrorCode$1["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = {}));
/**
* @license
* Copyright 2022 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Checks the status code to see if the action should be retried.
*
* @param status Current HTTP status code returned by server.
* @param additionalRetryCodes additional retry codes to check against
*/
function isRetryStatusCode(status, additionalRetryCodes) {
	const isFiveHundredCode = status >= 500 && status < 600;
	const isExtraRetryCode = [408, 429].indexOf(status) !== -1;
	const isAdditionalRetryCode = additionalRetryCodes.indexOf(status) !== -1;
	return isFiveHundredCode || isExtraRetryCode || isAdditionalRetryCode;
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Handles network logic for all Storage Requests, including error reporting and
* retries with backoff.
*
* @param I - the type of the backend's network response.
* @param - O the output type used by the rest of the SDK. The conversion
* happens in the specified `callback_`.
*/
var NetworkRequest = class {
	constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_, retry = true, isUsingEmulator = false) {
		this.url_ = url_;
		this.method_ = method_;
		this.headers_ = headers_;
		this.body_ = body_;
		this.successCodes_ = successCodes_;
		this.additionalRetryCodes_ = additionalRetryCodes_;
		this.callback_ = callback_;
		this.errorCallback_ = errorCallback_;
		this.timeout_ = timeout_;
		this.progressCallback_ = progressCallback_;
		this.connectionFactory_ = connectionFactory_;
		this.retry = retry;
		this.isUsingEmulator = isUsingEmulator;
		this.pendingConnection_ = null;
		this.backoffId_ = null;
		this.canceled_ = false;
		this.appDelete_ = false;
		this.promise_ = new Promise((resolve, reject) => {
			this.resolve_ = resolve;
			this.reject_ = reject;
			this.start_();
		});
	}
	/**
	* Actually starts the retry loop.
	*/
	start_() {
		const doTheRequest = (backoffCallback, canceled$1) => {
			if (canceled$1) {
				backoffCallback(false, new RequestEndStatus(false, null, true));
				return;
			}
			const connection = this.connectionFactory_();
			this.pendingConnection_ = connection;
			const progressListener = (progressEvent) => {
				const loaded = progressEvent.loaded;
				const total = progressEvent.lengthComputable ? progressEvent.total : -1;
				if (this.progressCallback_ !== null) this.progressCallback_(loaded, total);
			};
			if (this.progressCallback_ !== null) connection.addUploadProgressListener(progressListener);
			connection.send(this.url_, this.method_, this.isUsingEmulator, this.body_, this.headers_).then(() => {
				if (this.progressCallback_ !== null) connection.removeUploadProgressListener(progressListener);
				this.pendingConnection_ = null;
				const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;
				const status = connection.getStatus();
				if (!hitServer || isRetryStatusCode(status, this.additionalRetryCodes_) && this.retry) {
					backoffCallback(false, new RequestEndStatus(false, null, connection.getErrorCode() === ErrorCode.ABORT));
					return;
				}
				backoffCallback(true, new RequestEndStatus(this.successCodes_.indexOf(status) !== -1, connection));
			});
		};
		/**
		* @param requestWentThrough - True if the request eventually went
		*     through, false if it hit the retry limit or was canceled.
		*/
		const backoffDone = (requestWentThrough, status) => {
			const resolve = this.resolve_;
			const reject = this.reject_;
			const connection = status.connection;
			if (status.wasSuccessCode) try {
				const result = this.callback_(connection, connection.getResponse());
				if (isJustDef(result)) resolve(result);
				else resolve();
			} catch (e) {
				reject(e);
			}
			else if (connection !== null) {
				const err = unknown();
				err.serverResponse = connection.getErrorText();
				if (this.errorCallback_) reject(this.errorCallback_(connection, err));
				else reject(err);
			} else if (status.canceled) reject(this.appDelete_ ? appDeleted() : canceled());
			else reject(retryLimitExceeded());
		};
		if (this.canceled_) backoffDone(false, new RequestEndStatus(false, null, true));
		else this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
	}
	/** @inheritDoc */
	getPromise() {
		return this.promise_;
	}
	/** @inheritDoc */
	cancel(appDelete) {
		this.canceled_ = true;
		this.appDelete_ = appDelete || false;
		if (this.backoffId_ !== null) stop(this.backoffId_);
		if (this.pendingConnection_ !== null) this.pendingConnection_.abort();
	}
};
/**
* A collection of information about the result of a network request.
* @param opt_canceled - Defaults to false.
*/
var RequestEndStatus = class {
	constructor(wasSuccessCode, connection, canceled$1) {
		this.wasSuccessCode = wasSuccessCode;
		this.connection = connection;
		this.canceled = !!canceled$1;
	}
};
function addAuthHeader_(headers, authToken) {
	if (authToken !== null && authToken.length > 0) headers["Authorization"] = "Firebase " + authToken;
}
function addVersionHeader_(headers, firebaseVersion) {
	headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion ?? "AppManager");
}
function addGmpidHeader_(headers, appId) {
	if (appId) headers["X-Firebase-GMPID"] = appId;
}
function addAppCheckHeader_(headers, appCheckToken) {
	if (appCheckToken !== null) headers["X-Firebase-AppCheck"] = appCheckToken;
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion, retry = true, isUsingEmulator = false) {
	const queryPart = makeQueryString(requestInfo.urlParams);
	const url = requestInfo.url + queryPart;
	const headers = Object.assign({}, requestInfo.headers);
	addGmpidHeader_(headers, appId);
	addAuthHeader_(headers, authToken);
	addVersionHeader_(headers, firebaseVersion);
	addAppCheckHeader_(headers, appCheckToken);
	return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory, retry, isUsingEmulator);
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
function getBlobBuilder() {
	if (typeof BlobBuilder !== "undefined") return BlobBuilder;
	else if (typeof WebKitBlobBuilder !== "undefined") return WebKitBlobBuilder;
	else return;
}
/**
* Concatenates one or more values together and converts them to a Blob.
*
* @param args The values that will make up the resulting blob.
* @return The blob.
*/
function getBlob$1(...args) {
	const BlobBuilder$1 = getBlobBuilder();
	if (BlobBuilder$1 !== void 0) {
		const bb = new BlobBuilder$1();
		for (let i = 0; i < args.length; i++) bb.append(args[i]);
		return bb.getBlob();
	} else if (isNativeBlobDefined()) return new Blob(args);
	else throw new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, "This browser doesn't seem to support creating Blobs");
}
/**
* Slices the blob. The returned blob contains data from the start byte
* (inclusive) till the end byte (exclusive). Negative indices cannot be used.
*
* @param blob The blob to be sliced.
* @param start Index of the starting byte.
* @param end Index of the ending byte.
* @return The blob slice or null if not supported.
*/
function sliceBlob(blob, start$1, end) {
	if (blob.webkitSlice) return blob.webkitSlice(start$1, end);
	else if (blob.mozSlice) return blob.mozSlice(start$1, end);
	else if (blob.slice) return blob.slice(start$1, end);
	return null;
}
/**
* @license
* Copyright 2021 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/** Converts a Base64 encoded string to a binary string. */
function decodeBase64(encoded) {
	if (typeof atob === "undefined") throw missingPolyFill("base-64");
	return atob(encoded);
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* An enumeration of the possible string formats for upload.
* @public
*/
var StringFormat = {
	RAW: "raw",
	BASE64: "base64",
	BASE64URL: "base64url",
	DATA_URL: "data_url"
};
var StringData = class {
	constructor(data, contentType) {
		this.data = data;
		this.contentType = contentType || null;
	}
};
/**
* @internal
*/
function dataFromString(format, stringData) {
	switch (format) {
		case StringFormat.RAW: return new StringData(utf8Bytes_(stringData));
		case StringFormat.BASE64:
		case StringFormat.BASE64URL: return new StringData(base64Bytes_(format, stringData));
		case StringFormat.DATA_URL: return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
	}
	throw unknown();
}
function utf8Bytes_(value) {
	const b = [];
	for (let i = 0; i < value.length; i++) {
		let c = value.charCodeAt(i);
		if (c <= 127) b.push(c);
		else if (c <= 2047) b.push(192 | c >> 6, 128 | c & 63);
		else if ((c & 64512) === 55296) if (!(i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320)) b.push(239, 191, 189);
		else {
			const hi = c;
			const lo = value.charCodeAt(++i);
			c = 65536 | (hi & 1023) << 10 | lo & 1023;
			b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
		}
		else if ((c & 64512) === 56320) b.push(239, 191, 189);
		else b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
	}
	return new Uint8Array(b);
}
function percentEncodedBytes_(value) {
	let decoded;
	try {
		decoded = decodeURIComponent(value);
	} catch (e) {
		throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
	}
	return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
	switch (format) {
		case StringFormat.BASE64: {
			const hasMinus = value.indexOf("-") !== -1;
			const hasUnder = value.indexOf("_") !== -1;
			if (hasMinus || hasUnder) throw invalidFormat(format, "Invalid character '" + (hasMinus ? "-" : "_") + "' found: is it base64url encoded?");
			break;
		}
		case StringFormat.BASE64URL: {
			const hasPlus = value.indexOf("+") !== -1;
			const hasSlash = value.indexOf("/") !== -1;
			if (hasPlus || hasSlash) throw invalidFormat(format, "Invalid character '" + (hasPlus ? "+" : "/") + "' found: is it base64 encoded?");
			value = value.replace(/-/g, "+").replace(/_/g, "/");
			break;
		}
	}
	let bytes;
	try {
		bytes = decodeBase64(value);
	} catch (e) {
		if (e.message.includes("polyfill")) throw e;
		throw invalidFormat(format, "Invalid character found");
	}
	const array = new Uint8Array(bytes.length);
	for (let i = 0; i < bytes.length; i++) array[i] = bytes.charCodeAt(i);
	return array;
}
var DataURLParts = class {
	constructor(dataURL) {
		this.base64 = false;
		this.contentType = null;
		const matches = dataURL.match(/^data:([^,]+)?,/);
		if (matches === null) throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
		const middle = matches[1] || null;
		if (middle != null) {
			this.base64 = endsWith(middle, ";base64");
			this.contentType = this.base64 ? middle.substring(0, middle.length - 7) : middle;
		}
		this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
	}
};
function dataURLBytes_(dataUrl) {
	const parts = new DataURLParts(dataUrl);
	if (parts.base64) return base64Bytes_(StringFormat.BASE64, parts.rest);
	else return percentEncodedBytes_(parts.rest);
}
function dataURLContentType_(dataUrl) {
	return new DataURLParts(dataUrl).contentType;
}
function endsWith(s, end) {
	if (!(s.length >= end.length)) return false;
	return s.substring(s.length - end.length) === end;
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @param opt_elideCopy - If true, doesn't copy mutable input data
*     (e.g. Uint8Arrays). Pass true only if you know the objects will not be
*     modified after this blob's construction.
*
* @internal
*/
var FbsBlob = class FbsBlob {
	constructor(data, elideCopy) {
		let size = 0;
		let blobType = "";
		if (isNativeBlob(data)) {
			this.data_ = data;
			size = data.size;
			blobType = data.type;
		} else if (data instanceof ArrayBuffer) {
			if (elideCopy) this.data_ = new Uint8Array(data);
			else {
				this.data_ = new Uint8Array(data.byteLength);
				this.data_.set(new Uint8Array(data));
			}
			size = this.data_.length;
		} else if (data instanceof Uint8Array) {
			if (elideCopy) this.data_ = data;
			else {
				this.data_ = new Uint8Array(data.length);
				this.data_.set(data);
			}
			size = data.length;
		}
		this.size_ = size;
		this.type_ = blobType;
	}
	size() {
		return this.size_;
	}
	type() {
		return this.type_;
	}
	slice(startByte, endByte) {
		if (isNativeBlob(this.data_)) {
			const realBlob = this.data_;
			const sliced = sliceBlob(realBlob, startByte, endByte);
			if (sliced === null) return null;
			return new FbsBlob(sliced);
		} else return new FbsBlob(new Uint8Array(this.data_.buffer, startByte, endByte - startByte), true);
	}
	static getBlob(...args) {
		if (isNativeBlobDefined()) {
			const blobby = args.map((val) => {
				if (val instanceof FbsBlob) return val.data_;
				else return val;
			});
			return new FbsBlob(getBlob$1.apply(null, blobby));
		} else {
			const uint8Arrays = args.map((val) => {
				if (isString(val)) return dataFromString(StringFormat.RAW, val).data;
				else return val.data_;
			});
			let finalLength = 0;
			uint8Arrays.forEach((array) => {
				finalLength += array.byteLength;
			});
			const merged = new Uint8Array(finalLength);
			let index = 0;
			uint8Arrays.forEach((array) => {
				for (let i = 0; i < array.length; i++) merged[index++] = array[i];
			});
			return new FbsBlob(merged, true);
		}
	}
	uploadData() {
		return this.data_;
	}
};
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Returns the Object resulting from parsing the given JSON, or null if the
* given string does not represent a JSON object.
*/
function jsonObjectOrNull(s) {
	let obj;
	try {
		obj = JSON.parse(s);
	} catch (e) {
		return null;
	}
	if (isNonArrayObject(obj)) return obj;
	else return null;
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @fileoverview Contains helper methods for manipulating paths.
*/
/**
* @return Null if the path is already at the root.
*/
function parent(path) {
	if (path.length === 0) return null;
	const index = path.lastIndexOf("/");
	if (index === -1) return "";
	return path.slice(0, index);
}
function child(path, childPath) {
	const canonicalChildPath = childPath.split("/").filter((component) => component.length > 0).join("/");
	if (path.length === 0) return canonicalChildPath;
	else return path + "/" + canonicalChildPath;
}
/**
* Returns the last component of a path.
* '/foo/bar' -> 'bar'
* '/foo/bar/baz/' -> 'baz/'
* '/a' -> 'a'
*/
function lastComponent(path) {
	const index = path.lastIndexOf("/", path.length - 2);
	if (index === -1) return path;
	else return path.slice(index + 1);
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
function noXform_(metadata, value) {
	return value;
}
var Mapping = class {
	constructor(server, local, writable, xform) {
		this.server = server;
		this.local = local || server;
		this.writable = !!writable;
		this.xform = xform || noXform_;
	}
};
var mappings_ = null;
function xformPath(fullPath) {
	if (!isString(fullPath) || fullPath.length < 2) return fullPath;
	else return lastComponent(fullPath);
}
function getMappings() {
	if (mappings_) return mappings_;
	const mappings = [];
	mappings.push(new Mapping("bucket"));
	mappings.push(new Mapping("generation"));
	mappings.push(new Mapping("metageneration"));
	mappings.push(new Mapping("name", "fullPath", true));
	function mappingsXformPath(_metadata, fullPath) {
		return xformPath(fullPath);
	}
	const nameMapping = new Mapping("name");
	nameMapping.xform = mappingsXformPath;
	mappings.push(nameMapping);
	/**
	* Coerces the second param to a number, if it is defined.
	*/
	function xformSize(_metadata, size) {
		if (size !== void 0) return Number(size);
		else return size;
	}
	const sizeMapping = new Mapping("size");
	sizeMapping.xform = xformSize;
	mappings.push(sizeMapping);
	mappings.push(new Mapping("timeCreated"));
	mappings.push(new Mapping("updated"));
	mappings.push(new Mapping("md5Hash", null, true));
	mappings.push(new Mapping("cacheControl", null, true));
	mappings.push(new Mapping("contentDisposition", null, true));
	mappings.push(new Mapping("contentEncoding", null, true));
	mappings.push(new Mapping("contentLanguage", null, true));
	mappings.push(new Mapping("contentType", null, true));
	mappings.push(new Mapping("metadata", "customMetadata", true));
	mappings_ = mappings;
	return mappings_;
}
function addRef(metadata, service) {
	function generateRef() {
		const bucket = metadata["bucket"];
		const path = metadata["fullPath"];
		const loc = new Location(bucket, path);
		return service._makeStorageReference(loc);
	}
	Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
	const metadata = {};
	metadata["type"] = "file";
	const len = mappings.length;
	for (let i = 0; i < len; i++) {
		const mapping = mappings[i];
		metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
	}
	addRef(metadata, service);
	return metadata;
}
function fromResourceString(service, resourceString, mappings) {
	const obj = jsonObjectOrNull(resourceString);
	if (obj === null) return null;
	return fromResource(service, obj, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString, host, protocol) {
	const obj = jsonObjectOrNull(resourceString);
	if (obj === null) return null;
	if (!isString(obj["downloadTokens"])) return null;
	const tokens = obj["downloadTokens"];
	if (tokens.length === 0) return null;
	const encode = encodeURIComponent;
	return tokens.split(",").map((token) => {
		const bucket = metadata["bucket"];
		const path = metadata["fullPath"];
		return makeUrl("/b/" + encode(bucket) + "/o/" + encode(path), host, protocol) + makeQueryString({
			alt: "media",
			token
		});
	})[0];
}
function toResourceString(metadata, mappings) {
	const resource = {};
	const len = mappings.length;
	for (let i = 0; i < len; i++) {
		const mapping = mappings[i];
		if (mapping.writable) resource[mapping.server] = metadata[mapping.local];
	}
	return JSON.stringify(resource);
}
/**
* @license
* Copyright 2019 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var PREFIXES_KEY = "prefixes";
var ITEMS_KEY = "items";
function fromBackendResponse(service, bucket, resource) {
	const listResult = {
		prefixes: [],
		items: [],
		nextPageToken: resource["nextPageToken"]
	};
	if (resource[PREFIXES_KEY]) for (const path of resource[PREFIXES_KEY]) {
		const pathWithoutTrailingSlash = path.replace(/\/$/, "");
		const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
		listResult.prefixes.push(reference);
	}
	if (resource[ITEMS_KEY]) for (const item of resource[ITEMS_KEY]) {
		const reference = service._makeStorageReference(new Location(bucket, item["name"]));
		listResult.items.push(reference);
	}
	return listResult;
}
function fromResponseString(service, bucket, resourceString) {
	const obj = jsonObjectOrNull(resourceString);
	if (obj === null) return null;
	return fromBackendResponse(service, bucket, obj);
}
/**
* Contains a fully specified request.
*
* @param I - the type of the backend's network response.
* @param O - the output response type used by the rest of the SDK.
*/
var RequestInfo = class {
	constructor(url, method, handler, timeout) {
		this.url = url;
		this.method = method;
		this.handler = handler;
		this.timeout = timeout;
		this.urlParams = {};
		this.headers = {};
		this.body = null;
		this.errorHandler = null;
		/**
		* Called with the current number of bytes uploaded and total size (-1 if not
		* computable) of the request body (i.e. used to report upload progress).
		*/
		this.progressCallback = null;
		this.successCodes = [200];
		this.additionalRetryCodes = [];
	}
};
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Throws the UNKNOWN StorageError if cndn is false.
*/
function handlerCheck(cndn) {
	if (!cndn) throw unknown();
}
function metadataHandler(service, mappings) {
	function handler(xhr, text) {
		const metadata = fromResourceString(service, text, mappings);
		handlerCheck(metadata !== null);
		return metadata;
	}
	return handler;
}
function listHandler(service, bucket) {
	function handler(xhr, text) {
		const listResult = fromResponseString(service, bucket, text);
		handlerCheck(listResult !== null);
		return listResult;
	}
	return handler;
}
function downloadUrlHandler(service, mappings) {
	function handler(xhr, text) {
		const metadata = fromResourceString(service, text, mappings);
		handlerCheck(metadata !== null);
		return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);
	}
	return handler;
}
function sharedErrorHandler(location) {
	function errorHandler(xhr, err) {
		let newErr;
		if (xhr.getStatus() === 401) if (xhr.getErrorText().includes("Firebase App Check token is invalid")) newErr = unauthorizedApp();
		else newErr = unauthenticated();
		else if (xhr.getStatus() === 402) newErr = quotaExceeded(location.bucket);
		else if (xhr.getStatus() === 403) newErr = unauthorized(location.path);
		else newErr = err;
		newErr.status = xhr.getStatus();
		newErr.serverResponse = err.serverResponse;
		return newErr;
	}
	return errorHandler;
}
function objectErrorHandler(location) {
	const shared = sharedErrorHandler(location);
	function errorHandler(xhr, err) {
		let newErr = shared(xhr, err);
		if (xhr.getStatus() === 404) newErr = objectNotFound(location.path);
		newErr.serverResponse = err.serverResponse;
		return newErr;
	}
	return errorHandler;
}
function getMetadata$2(service, location, mappings) {
	const url = makeUrl(location.fullServerUrl(), service.host, service._protocol);
	const method = "GET";
	const timeout = service.maxOperationRetryTime;
	const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
	requestInfo.errorHandler = objectErrorHandler(location);
	return requestInfo;
}
function list$2(service, location, delimiter, pageToken, maxResults) {
	const urlParams = {};
	if (location.isRoot) urlParams["prefix"] = "";
	else urlParams["prefix"] = location.path + "/";
	if (delimiter && delimiter.length > 0) urlParams["delimiter"] = delimiter;
	if (pageToken) urlParams["pageToken"] = pageToken;
	if (maxResults) urlParams["maxResults"] = maxResults;
	const url = makeUrl(location.bucketOnlyServerUrl(), service.host, service._protocol);
	const method = "GET";
	const timeout = service.maxOperationRetryTime;
	const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);
	requestInfo.urlParams = urlParams;
	requestInfo.errorHandler = sharedErrorHandler(location);
	return requestInfo;
}
function getBytes$1(service, location, maxDownloadSizeBytes) {
	const url = makeUrl(location.fullServerUrl(), service.host, service._protocol) + "?alt=media";
	const method = "GET";
	const timeout = service.maxOperationRetryTime;
	const requestInfo = new RequestInfo(url, method, (_, data) => data, timeout);
	requestInfo.errorHandler = objectErrorHandler(location);
	if (maxDownloadSizeBytes !== void 0) {
		requestInfo.headers["Range"] = `bytes=0-${maxDownloadSizeBytes}`;
		requestInfo.successCodes = [200, 206];
	}
	return requestInfo;
}
function getDownloadUrl(service, location, mappings) {
	const url = makeUrl(location.fullServerUrl(), service.host, service._protocol);
	const method = "GET";
	const timeout = service.maxOperationRetryTime;
	const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
	requestInfo.errorHandler = objectErrorHandler(location);
	return requestInfo;
}
function updateMetadata$2(service, location, metadata, mappings) {
	const url = makeUrl(location.fullServerUrl(), service.host, service._protocol);
	const method = "PATCH";
	const body = toResourceString(metadata, mappings);
	const headers = { "Content-Type": "application/json; charset=utf-8" };
	const timeout = service.maxOperationRetryTime;
	const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
	requestInfo.headers = headers;
	requestInfo.body = body;
	requestInfo.errorHandler = objectErrorHandler(location);
	return requestInfo;
}
function deleteObject$2(service, location) {
	const url = makeUrl(location.fullServerUrl(), service.host, service._protocol);
	const method = "DELETE";
	const timeout = service.maxOperationRetryTime;
	function handler(_xhr, _text) {}
	const requestInfo = new RequestInfo(url, method, handler, timeout);
	requestInfo.successCodes = [200, 204];
	requestInfo.errorHandler = objectErrorHandler(location);
	return requestInfo;
}
function determineContentType_(metadata, blob) {
	return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location, blob, metadata) {
	const metadataClone = Object.assign({}, metadata);
	metadataClone["fullPath"] = location.path;
	metadataClone["size"] = blob.size();
	if (!metadataClone["contentType"]) metadataClone["contentType"] = determineContentType_(null, blob);
	return metadataClone;
}
/**
* Prepare RequestInfo for uploads as Content-Type: multipart.
*/
function multipartUpload(service, location, mappings, blob, metadata) {
	const urlPart = location.bucketOnlyServerUrl();
	const headers = { "X-Goog-Upload-Protocol": "multipart" };
	function genBoundary() {
		let str = "";
		for (let i = 0; i < 2; i++) str = str + Math.random().toString().slice(2);
		return str;
	}
	const boundary = genBoundary();
	headers["Content-Type"] = "multipart/related; boundary=" + boundary;
	const metadata_ = metadataForUpload_(location, blob, metadata);
	const metadataString = toResourceString(metadata_, mappings);
	const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
	const postBlobPart = "\r\n--" + boundary + "--";
	const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
	if (body === null) throw cannotSliceBlob();
	const urlParams = { name: metadata_["fullPath"] };
	const url = makeUrl(urlPart, service.host, service._protocol);
	const method = "POST";
	const timeout = service.maxUploadRetryTime;
	const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
	requestInfo.urlParams = urlParams;
	requestInfo.headers = headers;
	requestInfo.body = body.uploadData();
	requestInfo.errorHandler = sharedErrorHandler(location);
	return requestInfo;
}
/**
* @param current The number of bytes that have been uploaded so far.
* @param total The total number of bytes in the upload.
* @param opt_finalized True if the server has finished the upload.
* @param opt_metadata The upload metadata, should
*     only be passed if opt_finalized is true.
*/
var ResumableUploadStatus = class {
	constructor(current, total, finalized, metadata) {
		this.current = current;
		this.total = total;
		this.finalized = !!finalized;
		this.metadata = metadata || null;
	}
};
function checkResumeHeader_(xhr, allowed) {
	let status = null;
	try {
		status = xhr.getResponseHeader("X-Goog-Upload-Status");
	} catch (e) {
		handlerCheck(false);
	}
	handlerCheck(!!status && (allowed || ["active"]).indexOf(status) !== -1);
	return status;
}
function createResumableUpload(service, location, mappings, blob, metadata) {
	const urlPart = location.bucketOnlyServerUrl();
	const metadataForUpload = metadataForUpload_(location, blob, metadata);
	const urlParams = { name: metadataForUpload["fullPath"] };
	const url = makeUrl(urlPart, service.host, service._protocol);
	const method = "POST";
	const headers = {
		"X-Goog-Upload-Protocol": "resumable",
		"X-Goog-Upload-Command": "start",
		"X-Goog-Upload-Header-Content-Length": `${blob.size()}`,
		"X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
		"Content-Type": "application/json; charset=utf-8"
	};
	const body = toResourceString(metadataForUpload, mappings);
	const timeout = service.maxUploadRetryTime;
	function handler(xhr) {
		checkResumeHeader_(xhr);
		let url$1;
		try {
			url$1 = xhr.getResponseHeader("X-Goog-Upload-URL");
		} catch (e) {
			handlerCheck(false);
		}
		handlerCheck(isString(url$1));
		return url$1;
	}
	const requestInfo = new RequestInfo(url, method, handler, timeout);
	requestInfo.urlParams = urlParams;
	requestInfo.headers = headers;
	requestInfo.body = body;
	requestInfo.errorHandler = sharedErrorHandler(location);
	return requestInfo;
}
/**
* @param url From a call to fbs.requests.createResumableUpload.
*/
function getResumableUploadStatus(service, location, url, blob) {
	const headers = { "X-Goog-Upload-Command": "query" };
	function handler(xhr) {
		const status = checkResumeHeader_(xhr, ["active", "final"]);
		let sizeString = null;
		try {
			sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
		} catch (e) {
			handlerCheck(false);
		}
		if (!sizeString) handlerCheck(false);
		const size = Number(sizeString);
		handlerCheck(!isNaN(size));
		return new ResumableUploadStatus(size, blob.size(), status === "final");
	}
	const method = "POST";
	const timeout = service.maxUploadRetryTime;
	const requestInfo = new RequestInfo(url, method, handler, timeout);
	requestInfo.headers = headers;
	requestInfo.errorHandler = sharedErrorHandler(location);
	return requestInfo;
}
/**
* Any uploads via the resumable upload API must transfer a number of bytes
* that is a multiple of this number.
*/
var RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
/**
* @param url From a call to fbs.requests.createResumableUpload.
* @param chunkSize Number of bytes to upload.
* @param status The previous status.
*     If not passed or null, we start from the beginning.
* @throws fbs.Error If the upload is already complete, the passed in status
*     has a final size inconsistent with the blob, or the blob cannot be sliced
*     for upload.
*/
function continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {
	const status_ = new ResumableUploadStatus(0, 0);
	if (status) {
		status_.current = status.current;
		status_.total = status.total;
	} else {
		status_.current = 0;
		status_.total = blob.size();
	}
	if (blob.size() !== status_.total) throw serverFileWrongSize();
	const bytesLeft = status_.total - status_.current;
	let bytesToUpload = bytesLeft;
	if (chunkSize > 0) bytesToUpload = Math.min(bytesToUpload, chunkSize);
	const startByte = status_.current;
	const endByte = startByte + bytesToUpload;
	let uploadCommand = "";
	if (bytesToUpload === 0) uploadCommand = "finalize";
	else if (bytesLeft === bytesToUpload) uploadCommand = "upload, finalize";
	else uploadCommand = "upload";
	const headers = {
		"X-Goog-Upload-Command": uploadCommand,
		"X-Goog-Upload-Offset": `${status_.current}`
	};
	const body = blob.slice(startByte, endByte);
	if (body === null) throw cannotSliceBlob();
	function handler(xhr, text) {
		const uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
		const newCurrent = status_.current + bytesToUpload;
		const size = blob.size();
		let metadata;
		if (uploadStatus === "final") metadata = metadataHandler(service, mappings)(xhr, text);
		else metadata = null;
		return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
	}
	const method = "POST";
	const timeout = service.maxUploadRetryTime;
	const requestInfo = new RequestInfo(url, method, handler, timeout);
	requestInfo.headers = headers;
	requestInfo.body = body.uploadData();
	requestInfo.progressCallback = progressCallback || null;
	requestInfo.errorHandler = sharedErrorHandler(location);
	return requestInfo;
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* An event that is triggered on a task.
* @internal
*/
var TaskEvent = { STATE_CHANGED: "state_changed" };
/**
* Represents the current state of a running upload.
* @internal
*/
var TaskState = {
	RUNNING: "running",
	PAUSED: "paused",
	SUCCESS: "success",
	CANCELED: "canceled",
	ERROR: "error"
};
function taskStateFromInternalTaskState(state) {
	switch (state) {
		case "running":
		case "pausing":
		case "canceling": return TaskState.RUNNING;
		case "paused": return TaskState.PAUSED;
		case "success": return TaskState.SUCCESS;
		case "canceled": return TaskState.CANCELED;
		case "error": return TaskState.ERROR;
		default: return TaskState.ERROR;
	}
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Observer = class {
	constructor(nextOrObserver, error, complete) {
		if (isFunction(nextOrObserver) || error != null || complete != null) {
			this.next = nextOrObserver;
			this.error = error ?? void 0;
			this.complete = complete ?? void 0;
		} else {
			const observer = nextOrObserver;
			this.next = observer.next;
			this.error = observer.error;
			this.complete = observer.complete;
		}
	}
};
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Returns a function that invokes f with its arguments asynchronously as a
* microtask, i.e. as soon as possible after the current script returns back
* into browser code.
*/
function async(f) {
	return (...argsToForward) => {
		Promise.resolve().then(() => f(...argsToForward));
	};
}
/**
* Network layer for browsers. We use this instead of goog.net.XhrIo because
* goog.net.XhrIo is hyuuuuge and doesn't work in React Native on Android.
*/
var XhrConnection = class {
	constructor() {
		this.sent_ = false;
		this.xhr_ = new XMLHttpRequest();
		this.initXhr();
		this.errorCode_ = ErrorCode.NO_ERROR;
		this.sendPromise_ = new Promise((resolve) => {
			this.xhr_.addEventListener("abort", () => {
				this.errorCode_ = ErrorCode.ABORT;
				resolve();
			});
			this.xhr_.addEventListener("error", () => {
				this.errorCode_ = ErrorCode.NETWORK_ERROR;
				resolve();
			});
			this.xhr_.addEventListener("load", () => {
				resolve();
			});
		});
	}
	send(url, method, isUsingEmulator, body, headers) {
		if (this.sent_) throw internalError("cannot .send() more than once");
		if (isCloudWorkstation(url) && isUsingEmulator) this.xhr_.withCredentials = true;
		this.sent_ = true;
		this.xhr_.open(method, url, true);
		if (headers !== void 0) {
			for (const key in headers) if (headers.hasOwnProperty(key)) this.xhr_.setRequestHeader(key, headers[key].toString());
		}
		if (body !== void 0) this.xhr_.send(body);
		else this.xhr_.send();
		return this.sendPromise_;
	}
	getErrorCode() {
		if (!this.sent_) throw internalError("cannot .getErrorCode() before sending");
		return this.errorCode_;
	}
	getStatus() {
		if (!this.sent_) throw internalError("cannot .getStatus() before sending");
		try {
			return this.xhr_.status;
		} catch (e) {
			return -1;
		}
	}
	getResponse() {
		if (!this.sent_) throw internalError("cannot .getResponse() before sending");
		return this.xhr_.response;
	}
	getErrorText() {
		if (!this.sent_) throw internalError("cannot .getErrorText() before sending");
		return this.xhr_.statusText;
	}
	/** Aborts the request. */
	abort() {
		this.xhr_.abort();
	}
	getResponseHeader(header) {
		return this.xhr_.getResponseHeader(header);
	}
	addUploadProgressListener(listener) {
		if (this.xhr_.upload != null) this.xhr_.upload.addEventListener("progress", listener);
	}
	removeUploadProgressListener(listener) {
		if (this.xhr_.upload != null) this.xhr_.upload.removeEventListener("progress", listener);
	}
};
var XhrTextConnection = class extends XhrConnection {
	initXhr() {
		this.xhr_.responseType = "text";
	}
};
function newTextConnection() {
	return new XhrTextConnection();
}
var XhrBytesConnection = class extends XhrConnection {
	initXhr() {
		this.xhr_.responseType = "arraybuffer";
	}
};
function newBytesConnection() {
	return new XhrBytesConnection();
}
var XhrBlobConnection = class extends XhrConnection {
	initXhr() {
		this.xhr_.responseType = "blob";
	}
};
function newBlobConnection() {
	return new XhrBlobConnection();
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Represents a blob being uploaded. Can be used to pause/resume/cancel the
* upload and manage callbacks for various events.
* @internal
*/
var UploadTask = class {
	isExponentialBackoffExpired() {
		return this.sleepTime > this.maxSleepTime;
	}
	/**
	* @param ref - The firebaseStorage.Reference object this task came
	*     from, untyped to avoid cyclic dependencies.
	* @param blob - The blob to upload.
	*/
	constructor(ref$2, blob, metadata = null) {
		/**
		* Number of bytes transferred so far.
		*/
		this._transferred = 0;
		this._needToFetchStatus = false;
		this._needToFetchMetadata = false;
		this._observers = [];
		this._error = void 0;
		this._uploadUrl = void 0;
		this._request = void 0;
		this._chunkMultiplier = 1;
		this._resolve = void 0;
		this._reject = void 0;
		this._ref = ref$2;
		this._blob = blob;
		this._metadata = metadata;
		this._mappings = getMappings();
		this._resumable = this._shouldDoResumable(this._blob);
		this._state = "running";
		this._errorHandler = (error) => {
			this._request = void 0;
			this._chunkMultiplier = 1;
			if (error._codeEquals(StorageErrorCode.CANCELED)) {
				this._needToFetchStatus = true;
				this.completeTransitions_();
			} else {
				const backoffExpired = this.isExponentialBackoffExpired();
				if (isRetryStatusCode(error.status, [])) if (backoffExpired) error = retryLimitExceeded();
				else {
					this.sleepTime = Math.max(this.sleepTime * 2, DEFAULT_MIN_SLEEP_TIME_MILLIS);
					this._needToFetchStatus = true;
					this.completeTransitions_();
					return;
				}
				this._error = error;
				this._transition("error");
			}
		};
		this._metadataErrorHandler = (error) => {
			this._request = void 0;
			if (error._codeEquals(StorageErrorCode.CANCELED)) this.completeTransitions_();
			else {
				this._error = error;
				this._transition("error");
			}
		};
		this.sleepTime = 0;
		this.maxSleepTime = this._ref.storage.maxUploadRetryTime;
		this._promise = new Promise((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;
			this._start();
		});
		this._promise.then(null, () => {});
	}
	_makeProgressCallback() {
		const sizeBefore = this._transferred;
		return (loaded) => this._updateProgress(sizeBefore + loaded);
	}
	_shouldDoResumable(blob) {
		return blob.size() > 256 * 1024;
	}
	_start() {
		if (this._state !== "running") return;
		if (this._request !== void 0) return;
		if (this._resumable) if (this._uploadUrl === void 0) this._createResumable();
		else if (this._needToFetchStatus) this._fetchStatus();
		else if (this._needToFetchMetadata) this._fetchMetadata();
		else this.pendingTimeout = setTimeout(() => {
			this.pendingTimeout = void 0;
			this._continueUpload();
		}, this.sleepTime);
		else this._oneShotUpload();
	}
	_resolveToken(callback) {
		Promise.all([this._ref.storage._getAuthToken(), this._ref.storage._getAppCheckToken()]).then(([authToken, appCheckToken]) => {
			switch (this._state) {
				case "running":
					callback(authToken, appCheckToken);
					break;
				case "canceling":
					this._transition("canceled");
					break;
				case "pausing":
					this._transition("paused");
					break;
			}
		});
	}
	_createResumable() {
		this._resolveToken((authToken, appCheckToken) => {
			const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
			const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
			this._request = createRequest;
			createRequest.getPromise().then((url) => {
				this._request = void 0;
				this._uploadUrl = url;
				this._needToFetchStatus = false;
				this.completeTransitions_();
			}, this._errorHandler);
		});
	}
	_fetchStatus() {
		const url = this._uploadUrl;
		this._resolveToken((authToken, appCheckToken) => {
			const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);
			const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
			this._request = statusRequest;
			statusRequest.getPromise().then((status) => {
				status = status;
				this._request = void 0;
				this._updateProgress(status.current);
				this._needToFetchStatus = false;
				if (status.finalized) this._needToFetchMetadata = true;
				this.completeTransitions_();
			}, this._errorHandler);
		});
	}
	_continueUpload() {
		const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
		const status = new ResumableUploadStatus(this._transferred, this._blob.size());
		const url = this._uploadUrl;
		this._resolveToken((authToken, appCheckToken) => {
			let requestInfo;
			try {
				requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());
			} catch (e) {
				this._error = e;
				this._transition("error");
				return;
			}
			const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken, false);
			this._request = uploadRequest;
			uploadRequest.getPromise().then((newStatus) => {
				this._increaseMultiplier();
				this._request = void 0;
				this._updateProgress(newStatus.current);
				if (newStatus.finalized) {
					this._metadata = newStatus.metadata;
					this._transition("success");
				} else this.completeTransitions_();
			}, this._errorHandler);
		});
	}
	_increaseMultiplier() {
		if (RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier * 2 < 32 * 1024 * 1024) this._chunkMultiplier *= 2;
	}
	_fetchMetadata() {
		this._resolveToken((authToken, appCheckToken) => {
			const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);
			const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
			this._request = metadataRequest;
			metadataRequest.getPromise().then((metadata) => {
				this._request = void 0;
				this._metadata = metadata;
				this._transition("success");
			}, this._metadataErrorHandler);
		});
	}
	_oneShotUpload() {
		this._resolveToken((authToken, appCheckToken) => {
			const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
			const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
			this._request = multipartRequest;
			multipartRequest.getPromise().then((metadata) => {
				this._request = void 0;
				this._metadata = metadata;
				this._updateProgress(this._blob.size());
				this._transition("success");
			}, this._errorHandler);
		});
	}
	_updateProgress(transferred) {
		const old = this._transferred;
		this._transferred = transferred;
		if (this._transferred !== old) this._notifyObservers();
	}
	_transition(state) {
		if (this._state === state) return;
		switch (state) {
			case "canceling":
			case "pausing":
				this._state = state;
				if (this._request !== void 0) this._request.cancel();
				else if (this.pendingTimeout) {
					clearTimeout(this.pendingTimeout);
					this.pendingTimeout = void 0;
					this.completeTransitions_();
				}
				break;
			case "running":
				const wasPaused = this._state === "paused";
				this._state = state;
				if (wasPaused) {
					this._notifyObservers();
					this._start();
				}
				break;
			case "paused":
				this._state = state;
				this._notifyObservers();
				break;
			case "canceled":
				this._error = canceled();
				this._state = state;
				this._notifyObservers();
				break;
			case "error":
				this._state = state;
				this._notifyObservers();
				break;
			case "success":
				this._state = state;
				this._notifyObservers();
				break;
		}
	}
	completeTransitions_() {
		switch (this._state) {
			case "pausing":
				this._transition("paused");
				break;
			case "canceling":
				this._transition("canceled");
				break;
			case "running":
				this._start();
				break;
		}
	}
	/**
	* A snapshot of the current task state.
	*/
	get snapshot() {
		const externalState = taskStateFromInternalTaskState(this._state);
		return {
			bytesTransferred: this._transferred,
			totalBytes: this._blob.size(),
			state: externalState,
			metadata: this._metadata,
			task: this,
			ref: this._ref
		};
	}
	/**
	* Adds a callback for an event.
	* @param type - The type of event to listen for.
	* @param nextOrObserver -
	*     The `next` function, which gets called for each item in
	*     the event stream, or an observer object with some or all of these three
	*     properties (`next`, `error`, `complete`).
	* @param error - A function that gets called with a `StorageError`
	*     if the event stream ends due to an error.
	* @param completed - A function that gets called if the
	*     event stream ends normally.
	* @returns
	*     If only the event argument is passed, returns a function you can use to
	*     add callbacks (see the examples above). If more than just the event
	*     argument is passed, returns a function you can call to unregister the
	*     callbacks.
	*/
	on(type, nextOrObserver, error, completed) {
		const observer = new Observer(nextOrObserver || void 0, error || void 0, completed || void 0);
		this._addObserver(observer);
		return () => {
			this._removeObserver(observer);
		};
	}
	/**
	* This object behaves like a Promise, and resolves with its snapshot data
	* when the upload completes.
	* @param onFulfilled - The fulfillment callback. Promise chaining works as normal.
	* @param onRejected - The rejection callback.
	*/
	then(onFulfilled, onRejected) {
		return this._promise.then(onFulfilled, onRejected);
	}
	/**
	* Equivalent to calling `then(null, onRejected)`.
	*/
	catch(onRejected) {
		return this.then(null, onRejected);
	}
	/**
	* Adds the given observer.
	*/
	_addObserver(observer) {
		this._observers.push(observer);
		this._notifyObserver(observer);
	}
	/**
	* Removes the given observer.
	*/
	_removeObserver(observer) {
		const i = this._observers.indexOf(observer);
		if (i !== -1) this._observers.splice(i, 1);
	}
	_notifyObservers() {
		this._finishPromise();
		this._observers.slice().forEach((observer) => {
			this._notifyObserver(observer);
		});
	}
	_finishPromise() {
		if (this._resolve !== void 0) {
			let triggered = true;
			switch (taskStateFromInternalTaskState(this._state)) {
				case TaskState.SUCCESS:
					async(this._resolve.bind(null, this.snapshot))();
					break;
				case TaskState.CANCELED:
				case TaskState.ERROR:
					const toCall = this._reject;
					async(toCall.bind(null, this._error))();
					break;
				default:
					triggered = false;
					break;
			}
			if (triggered) {
				this._resolve = void 0;
				this._reject = void 0;
			}
		}
	}
	_notifyObserver(observer) {
		switch (taskStateFromInternalTaskState(this._state)) {
			case TaskState.RUNNING:
			case TaskState.PAUSED:
				if (observer.next) async(observer.next.bind(observer, this.snapshot))();
				break;
			case TaskState.SUCCESS:
				if (observer.complete) async(observer.complete.bind(observer))();
				break;
			case TaskState.CANCELED:
			case TaskState.ERROR:
				if (observer.error) async(observer.error.bind(observer, this._error))();
				break;
			default: if (observer.error) async(observer.error.bind(observer, this._error))();
		}
	}
	/**
	* Resumes a paused task. Has no effect on a currently running or failed task.
	* @returns True if the operation took effect, false if ignored.
	*/
	resume() {
		const valid = this._state === "paused" || this._state === "pausing";
		if (valid) this._transition("running");
		return valid;
	}
	/**
	* Pauses a currently running task. Has no effect on a paused or failed task.
	* @returns True if the operation took effect, false if ignored.
	*/
	pause() {
		const valid = this._state === "running";
		if (valid) this._transition("pausing");
		return valid;
	}
	/**
	* Cancels a currently running or paused task. Has no effect on a complete or
	* failed task.
	* @returns True if the operation took effect, false if ignored.
	*/
	cancel() {
		const valid = this._state === "running" || this._state === "pausing";
		if (valid) this._transition("canceling");
		return valid;
	}
};
/**
* @license
* Copyright 2019 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Provides methods to interact with a bucket in the Firebase Storage service.
* @internal
* @param _location - An fbs.location, or the URL at
*     which to base this object, in one of the following forms:
*         gs://<bucket>/<object-path>
*         http[s]://firebasestorage.googleapis.com/
*                     <api-version>/b/<bucket>/o/<object-path>
*     Any query or fragment strings will be ignored in the http[s]
*     format. If no value is passed, the storage object will use a URL based on
*     the project ID of the base firebase.App instance.
*/
var Reference = class Reference {
	constructor(_service, location) {
		this._service = _service;
		if (location instanceof Location) this._location = location;
		else this._location = Location.makeFromUrl(location, _service.host);
	}
	/**
	* Returns the URL for the bucket and path this object references,
	*     in the form gs://<bucket>/<object-path>
	* @override
	*/
	toString() {
		return "gs://" + this._location.bucket + "/" + this._location.path;
	}
	_newRef(service, location) {
		return new Reference(service, location);
	}
	/**
	* A reference to the root of this object's bucket.
	*/
	get root() {
		const location = new Location(this._location.bucket, "");
		return this._newRef(this._service, location);
	}
	/**
	* The name of the bucket containing this reference's object.
	*/
	get bucket() {
		return this._location.bucket;
	}
	/**
	* The full path of this object.
	*/
	get fullPath() {
		return this._location.path;
	}
	/**
	* The short name of this object, which is the last component of the full path.
	* For example, if fullPath is 'full/path/image.png', name is 'image.png'.
	*/
	get name() {
		return lastComponent(this._location.path);
	}
	/**
	* The `StorageService` instance this `StorageReference` is associated with.
	*/
	get storage() {
		return this._service;
	}
	/**
	* A `StorageReference` pointing to the parent location of this `StorageReference`, or null if
	* this reference is the root.
	*/
	get parent() {
		const newPath = parent(this._location.path);
		if (newPath === null) return null;
		const location = new Location(this._location.bucket, newPath);
		return new Reference(this._service, location);
	}
	/**
	* Utility function to throw an error in methods that do not accept a root reference.
	*/
	_throwIfRoot(name$1) {
		if (this._location.path === "") throw invalidRootOperation(name$1);
	}
};
/**
* Download the bytes at the object's location.
* @returns A Promise containing the downloaded bytes.
*/
function getBytesInternal(ref$2, maxDownloadSizeBytes) {
	ref$2._throwIfRoot("getBytes");
	const requestInfo = getBytes$1(ref$2.storage, ref$2._location, maxDownloadSizeBytes);
	return ref$2.storage.makeRequestWithTokens(requestInfo, newBytesConnection).then((bytes) => maxDownloadSizeBytes !== void 0 ? bytes.slice(0, maxDownloadSizeBytes) : bytes);
}
/**
* Download the bytes at the object's location.
* @returns A Promise containing the downloaded blob.
*/
function getBlobInternal(ref$2, maxDownloadSizeBytes) {
	ref$2._throwIfRoot("getBlob");
	const requestInfo = getBytes$1(ref$2.storage, ref$2._location, maxDownloadSizeBytes);
	return ref$2.storage.makeRequestWithTokens(requestInfo, newBlobConnection).then((blob) => maxDownloadSizeBytes !== void 0 ? blob.slice(0, maxDownloadSizeBytes) : blob);
}
/**
* Uploads data to this object's location.
* The upload is not resumable.
*
* @param ref - StorageReference where data should be uploaded.
* @param data - The data to upload.
* @param metadata - Metadata for the newly uploaded data.
* @returns A Promise containing an UploadResult
*/
function uploadBytes$1(ref$2, data, metadata) {
	ref$2._throwIfRoot("uploadBytes");
	const requestInfo = multipartUpload(ref$2.storage, ref$2._location, getMappings(), new FbsBlob(data, true), metadata);
	return ref$2.storage.makeRequestWithTokens(requestInfo, newTextConnection).then((finalMetadata) => {
		return {
			metadata: finalMetadata,
			ref: ref$2
		};
	});
}
/**
* Uploads data to this object's location.
* The upload can be paused and resumed, and exposes progress updates.
* @public
* @param ref - StorageReference where data should be uploaded.
* @param data - The data to upload.
* @param metadata - Metadata for the newly uploaded data.
* @returns An UploadTask
*/
function uploadBytesResumable$1(ref$2, data, metadata) {
	ref$2._throwIfRoot("uploadBytesResumable");
	return new UploadTask(ref$2, new FbsBlob(data), metadata);
}
/**
* Uploads a string to this object's location.
* The upload is not resumable.
* @public
* @param ref - StorageReference where string should be uploaded.
* @param value - The string to upload.
* @param format - The format of the string to upload.
* @param metadata - Metadata for the newly uploaded string.
* @returns A Promise containing an UploadResult
*/
function uploadString$1(ref$2, value, format = StringFormat.RAW, metadata) {
	ref$2._throwIfRoot("uploadString");
	const data = dataFromString(format, value);
	const metadataClone = { ...metadata };
	if (metadataClone["contentType"] == null && data.contentType != null) metadataClone["contentType"] = data.contentType;
	return uploadBytes$1(ref$2, data.data, metadataClone);
}
/**
* List all items (files) and prefixes (folders) under this storage reference.
*
* This is a helper method for calling list() repeatedly until there are
* no more results. The default pagination size is 1000.
*
* Note: The results may not be consistent if objects are changed while this
* operation is running.
*
* Warning: listAll may potentially consume too many resources if there are
* too many results.
* @public
* @param ref - StorageReference to get list from.
*
* @returns A Promise that resolves with all the items and prefixes under
*      the current storage reference. `prefixes` contains references to
*      sub-directories and `items` contains references to objects in this
*      folder. `nextPageToken` is never returned.
*/
function listAll$1(ref$2) {
	const accumulator = {
		prefixes: [],
		items: []
	};
	return listAllHelper(ref$2, accumulator).then(() => accumulator);
}
/**
* Separated from listAll because async functions can't use "arguments".
* @param ref
* @param accumulator
* @param pageToken
*/
async function listAllHelper(ref$2, accumulator, pageToken) {
	const nextPage = await list$1(ref$2, { pageToken });
	accumulator.prefixes.push(...nextPage.prefixes);
	accumulator.items.push(...nextPage.items);
	if (nextPage.nextPageToken != null) await listAllHelper(ref$2, accumulator, nextPage.nextPageToken);
}
/**
* List items (files) and prefixes (folders) under this storage reference.
*
* List API is only available for Firebase Rules Version 2.
*
* GCS is a key-blob store. Firebase Storage imposes the semantic of '/'
* delimited folder structure.
* Refer to GCS's List API if you want to learn more.
*
* To adhere to Firebase Rules's Semantics, Firebase Storage does not
* support objects whose paths end with "/" or contain two consecutive
* "/"s. Firebase Storage List API will filter these unsupported objects.
* list() may fail if there are too many unsupported objects in the bucket.
* @public
*
* @param ref - StorageReference to get list from.
* @param options - See ListOptions for details.
* @returns A Promise that resolves with the items and prefixes.
*      `prefixes` contains references to sub-folders and `items`
*      contains references to objects in this folder. `nextPageToken`
*      can be used to get the rest of the results.
*/
function list$1(ref$2, options) {
	if (options != null) {
		if (typeof options.maxResults === "number") validateNumber("options.maxResults", 1, 1e3, options.maxResults);
	}
	const op = options || {};
	const requestInfo = list$2(ref$2.storage, ref$2._location, "/", op.pageToken, op.maxResults);
	return ref$2.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
* A `Promise` that resolves with the metadata for this object. If this
* object doesn't exist or metadata cannot be retrieved, the promise is
* rejected.
* @public
* @param ref - StorageReference to get metadata from.
*/
function getMetadata$1(ref$2) {
	ref$2._throwIfRoot("getMetadata");
	const requestInfo = getMetadata$2(ref$2.storage, ref$2._location, getMappings());
	return ref$2.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
* Updates the metadata for this object.
* @public
* @param ref - StorageReference to update metadata for.
* @param metadata - The new metadata for the object.
*     Only values that have been explicitly set will be changed. Explicitly
*     setting a value to null will remove the metadata.
* @returns A `Promise` that resolves
*     with the new metadata for this object.
*     See `firebaseStorage.Reference.prototype.getMetadata`
*/
function updateMetadata$1(ref$2, metadata) {
	ref$2._throwIfRoot("updateMetadata");
	const requestInfo = updateMetadata$2(ref$2.storage, ref$2._location, metadata, getMappings());
	return ref$2.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
* Returns the download URL for the given Reference.
* @public
* @returns A `Promise` that resolves with the download
*     URL for this object.
*/
function getDownloadURL$1(ref$2) {
	ref$2._throwIfRoot("getDownloadURL");
	const requestInfo = getDownloadUrl(ref$2.storage, ref$2._location, getMappings());
	return ref$2.storage.makeRequestWithTokens(requestInfo, newTextConnection).then((url) => {
		if (url === null) throw noDownloadURL();
		return url;
	});
}
/**
* Deletes the object at this location.
* @public
* @param ref - StorageReference for object to delete.
* @returns A `Promise` that resolves if the deletion succeeds.
*/
function deleteObject$1(ref$2) {
	ref$2._throwIfRoot("deleteObject");
	const requestInfo = deleteObject$2(ref$2.storage, ref$2._location);
	return ref$2.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
* Returns reference for object obtained by appending `childPath` to `ref`.
*
* @param ref - StorageReference to get child of.
* @param childPath - Child path from provided ref.
* @returns A reference to the object obtained by
* appending childPath, removing any duplicate, beginning, or trailing
* slashes.
*
*/
function _getChild$1(ref$2, childPath) {
	const newPath = child(ref$2._location.path, childPath);
	const location = new Location(ref$2._location.bucket, newPath);
	return new Reference(ref$2.storage, location);
}
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
function isUrl(path) {
	return /^[A-Za-z]+:\/\//.test(path);
}
/**
* Returns a firebaseStorage.Reference for the given url.
*/
function refFromURL(service, url) {
	return new Reference(service, url);
}
/**
* Returns a firebaseStorage.Reference for the given path in the default
* bucket.
*/
function refFromPath(ref$2, path) {
	if (ref$2 instanceof FirebaseStorageImpl) {
		const service = ref$2;
		if (service._bucket == null) throw noDefaultBucket();
		const reference = new Reference(service, service._bucket);
		if (path != null) return refFromPath(reference, path);
		else return reference;
	} else if (path !== void 0) return _getChild$1(ref$2, path);
	else return ref$2;
}
function ref$1(serviceOrRef, pathOrUrl) {
	if (pathOrUrl && isUrl(pathOrUrl)) if (serviceOrRef instanceof FirebaseStorageImpl) return refFromURL(serviceOrRef, pathOrUrl);
	else throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
	else return refFromPath(serviceOrRef, pathOrUrl);
}
function extractBucket(host, config) {
	const bucketString = config?.[CONFIG_STORAGE_BUCKET_KEY];
	if (bucketString == null) return null;
	return Location.makeFromBucketSpec(bucketString, host);
}
function connectStorageEmulator$1(storage, host, port, options = {}) {
	storage.host = `${host}:${port}`;
	const useSsl = isCloudWorkstation(host);
	if (useSsl) {
		pingServer(`https://${storage.host}/b`);
		updateEmulatorBanner("Storage", true);
	}
	storage._isUsingEmulator = true;
	storage._protocol = useSsl ? "https" : "http";
	const { mockUserToken } = options;
	if (mockUserToken) storage._overrideAuthToken = typeof mockUserToken === "string" ? mockUserToken : createMockUserToken(mockUserToken, storage.app.options.projectId);
}
/**
* A service that provides Firebase Storage Reference instances.
* @param opt_url - gs:// url to a custom Storage Bucket
*
* @internal
*/
var FirebaseStorageImpl = class {
	constructor(app, _authProvider, _appCheckProvider, _url, _firebaseVersion, _isUsingEmulator = false) {
		this.app = app;
		this._authProvider = _authProvider;
		this._appCheckProvider = _appCheckProvider;
		this._url = _url;
		this._firebaseVersion = _firebaseVersion;
		this._isUsingEmulator = _isUsingEmulator;
		this._bucket = null;
		/**
		* This string can be in the formats:
		* - host
		* - host:port
		*/
		this._host = DEFAULT_HOST;
		this._protocol = "https";
		this._appId = null;
		this._deleted = false;
		this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
		this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
		this._requests = /* @__PURE__ */ new Set();
		if (_url != null) this._bucket = Location.makeFromBucketSpec(_url, this._host);
		else this._bucket = extractBucket(this._host, this.app.options);
	}
	/**
	* The host string for this service, in the form of `host` or
	* `host:port`.
	*/
	get host() {
		return this._host;
	}
	set host(host) {
		this._host = host;
		if (this._url != null) this._bucket = Location.makeFromBucketSpec(this._url, host);
		else this._bucket = extractBucket(host, this.app.options);
	}
	/**
	* The maximum time to retry uploads in milliseconds.
	*/
	get maxUploadRetryTime() {
		return this._maxUploadRetryTime;
	}
	set maxUploadRetryTime(time) {
		validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
		this._maxUploadRetryTime = time;
	}
	/**
	* The maximum time to retry operations other than uploads or downloads in
	* milliseconds.
	*/
	get maxOperationRetryTime() {
		return this._maxOperationRetryTime;
	}
	set maxOperationRetryTime(time) {
		validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
		this._maxOperationRetryTime = time;
	}
	async _getAuthToken() {
		if (this._overrideAuthToken) return this._overrideAuthToken;
		const auth = this._authProvider.getImmediate({ optional: true });
		if (auth) {
			const tokenData = await auth.getToken();
			if (tokenData !== null) return tokenData.accessToken;
		}
		return null;
	}
	async _getAppCheckToken() {
		if (_isFirebaseServerApp(this.app) && this.app.settings.appCheckToken) return this.app.settings.appCheckToken;
		const appCheck = this._appCheckProvider.getImmediate({ optional: true });
		if (appCheck) return (await appCheck.getToken()).token;
		return null;
	}
	/**
	* Stop running requests and prevent more from being created.
	*/
	_delete() {
		if (!this._deleted) {
			this._deleted = true;
			this._requests.forEach((request) => request.cancel());
			this._requests.clear();
		}
		return Promise.resolve();
	}
	/**
	* Returns a new firebaseStorage.Reference object referencing this StorageService
	* at the given Location.
	*/
	_makeStorageReference(loc) {
		return new Reference(this, loc);
	}
	/**
	* @param requestInfo - HTTP RequestInfo object
	* @param authToken - Firebase auth token
	*/
	_makeRequest(requestInfo, requestFactory, authToken, appCheckToken, retry = true) {
		if (!this._deleted) {
			const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion, retry, this._isUsingEmulator);
			this._requests.add(request);
			request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
			return request;
		} else return new FailRequest(appDeleted());
	}
	async makeRequestWithTokens(requestInfo, requestFactory) {
		const [authToken, appCheckToken] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]);
		return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();
	}
};
var name = "@firebase/storage";
var version = "0.14.0";
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Type constant for Firebase Storage.
*/
var STORAGE_TYPE = "storage";
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Downloads the data at the object's location. Returns an error if the object
* is not found.
*
* To use this functionality, you have to whitelist your app's origin in your
* Cloud Storage bucket. See also
* https://cloud.google.com/storage/docs/configuring-cors
*
* @public
* @param ref - StorageReference where data should be downloaded.
* @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to
* retrieve.
* @returns A Promise containing the object's bytes
*/
function getBytes(ref$2, maxDownloadSizeBytes) {
	ref$2 = getModularInstance(ref$2);
	return getBytesInternal(ref$2, maxDownloadSizeBytes);
}
/**
* Uploads data to this object's location.
* The upload is not resumable.
* @public
* @param ref - {@link StorageReference} where data should be uploaded.
* @param data - The data to upload.
* @param metadata - Metadata for the data to upload.
* @returns A Promise containing an UploadResult
*/
function uploadBytes(ref$2, data, metadata) {
	ref$2 = getModularInstance(ref$2);
	return uploadBytes$1(ref$2, data, metadata);
}
/**
* Uploads a string to this object's location.
* The upload is not resumable.
* @public
* @param ref - {@link StorageReference} where string should be uploaded.
* @param value - The string to upload.
* @param format - The format of the string to upload.
* @param metadata - Metadata for the string to upload.
* @returns A Promise containing an UploadResult
*/
function uploadString(ref$2, value, format, metadata) {
	ref$2 = getModularInstance(ref$2);
	return uploadString$1(ref$2, value, format, metadata);
}
/**
* Uploads data to this object's location.
* The upload can be paused and resumed, and exposes progress updates.
* @public
* @param ref - {@link StorageReference} where data should be uploaded.
* @param data - The data to upload.
* @param metadata - Metadata for the data to upload.
* @returns An UploadTask
*/
function uploadBytesResumable(ref$2, data, metadata) {
	ref$2 = getModularInstance(ref$2);
	return uploadBytesResumable$1(ref$2, data, metadata);
}
/**
* A `Promise` that resolves with the metadata for this object. If this
* object doesn't exist or metadata cannot be retrieved, the promise is
* rejected.
* @public
* @param ref - {@link StorageReference} to get metadata from.
*/
function getMetadata(ref$2) {
	ref$2 = getModularInstance(ref$2);
	return getMetadata$1(ref$2);
}
/**
* Updates the metadata for this object.
* @public
* @param ref - {@link StorageReference} to update metadata for.
* @param metadata - The new metadata for the object.
*     Only values that have been explicitly set will be changed. Explicitly
*     setting a value to null will remove the metadata.
* @returns A `Promise` that resolves with the new metadata for this object.
*/
function updateMetadata(ref$2, metadata) {
	ref$2 = getModularInstance(ref$2);
	return updateMetadata$1(ref$2, metadata);
}
/**
* List items (files) and prefixes (folders) under this storage reference.
*
* List API is only available for Firebase Rules Version 2.
*
* GCS is a key-blob store. Firebase Storage imposes the semantic of '/'
* delimited folder structure.
* Refer to GCS's List API if you want to learn more.
*
* To adhere to Firebase Rules's Semantics, Firebase Storage does not
* support objects whose paths end with "/" or contain two consecutive
* "/"s. Firebase Storage List API will filter these unsupported objects.
* list() may fail if there are too many unsupported objects in the bucket.
* @public
*
* @param ref - {@link StorageReference} to get list from.
* @param options - See {@link ListOptions} for details.
* @returns A `Promise` that resolves with the items and prefixes.
*      `prefixes` contains references to sub-folders and `items`
*      contains references to objects in this folder. `nextPageToken`
*      can be used to get the rest of the results.
*/
function list(ref$2, options) {
	ref$2 = getModularInstance(ref$2);
	return list$1(ref$2, options);
}
/**
* List all items (files) and prefixes (folders) under this storage reference.
*
* This is a helper method for calling list() repeatedly until there are
* no more results. The default pagination size is 1000.
*
* Note: The results may not be consistent if objects are changed while this
* operation is running.
*
* Warning: `listAll` may potentially consume too many resources if there are
* too many results.
* @public
* @param ref - {@link StorageReference} to get list from.
*
* @returns A `Promise` that resolves with all the items and prefixes under
*      the current storage reference. `prefixes` contains references to
*      sub-directories and `items` contains references to objects in this
*      folder. `nextPageToken` is never returned.
*/
function listAll(ref$2) {
	ref$2 = getModularInstance(ref$2);
	return listAll$1(ref$2);
}
/**
* Returns the download URL for the given {@link StorageReference}.
* @public
* @param ref - {@link StorageReference} to get the download URL for.
* @returns A `Promise` that resolves with the download
*     URL for this object.
*/
function getDownloadURL(ref$2) {
	ref$2 = getModularInstance(ref$2);
	return getDownloadURL$1(ref$2);
}
/**
* Deletes the object at this location.
* @public
* @param ref - {@link StorageReference} for object to delete.
* @returns A `Promise` that resolves if the deletion succeeds.
*/
function deleteObject(ref$2) {
	ref$2 = getModularInstance(ref$2);
	return deleteObject$1(ref$2);
}
function ref(serviceOrRef, pathOrUrl) {
	serviceOrRef = getModularInstance(serviceOrRef);
	return ref$1(serviceOrRef, pathOrUrl);
}
/**
* @internal
*/
function _getChild(ref$2, childPath) {
	return _getChild$1(ref$2, childPath);
}
/**
* Gets a {@link FirebaseStorage} instance for the given Firebase app.
* @public
* @param app - Firebase app to get {@link FirebaseStorage} instance for.
* @param bucketUrl - The gs:// url to your Firebase Storage Bucket.
* If not passed, uses the app's default Storage Bucket.
* @returns A {@link FirebaseStorage} instance.
*/
function getStorage(app = getApp(), bucketUrl) {
	app = getModularInstance(app);
	const storageInstance = _getProvider(app, STORAGE_TYPE).getImmediate({ identifier: bucketUrl });
	const emulator = getDefaultEmulatorHostnameAndPort("storage");
	if (emulator) connectStorageEmulator(storageInstance, ...emulator);
	return storageInstance;
}
/**
* Modify this {@link FirebaseStorage} instance to communicate with the Cloud Storage emulator.
*
* @param storage - The {@link FirebaseStorage} instance
* @param host - The emulator host (ex: localhost)
* @param port - The emulator port (ex: 5001)
* @param options - Emulator options. `options.mockUserToken` is the mock auth
* token to use for unit testing Security Rules.
* @public
*/
function connectStorageEmulator(storage, host, port, options = {}) {
	connectStorageEmulator$1(storage, host, port, options);
}
/**
* @license
* Copyright 2021 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Downloads the data at the object's location. Returns an error if the object
* is not found.
*
* To use this functionality, you have to whitelist your app's origin in your
* Cloud Storage bucket. See also
* https://cloud.google.com/storage/docs/configuring-cors
*
* This API is not available in Node.
*
* @public
* @param ref - StorageReference where data should be downloaded.
* @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to
* retrieve.
* @returns A Promise that resolves with a Blob containing the object's bytes
*/
function getBlob(ref$2, maxDownloadSizeBytes) {
	ref$2 = getModularInstance(ref$2);
	return getBlobInternal(ref$2, maxDownloadSizeBytes);
}
/**
* Downloads the data at the object's location. Raises an error event if the
* object is not found.
*
* This API is only available in Node.
*
* @public
* @param ref - StorageReference where data should be downloaded.
* @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to
* retrieve.
* @returns A stream with the object's data as bytes
*/
function getStream(ref$2, maxDownloadSizeBytes) {
	throw new Error("getStream() is only supported by NodeJS builds");
}
/**
* Cloud Storage for Firebase
*
* @packageDocumentation
*/
function factory(container, { instanceIdentifier: url }) {
	return new FirebaseStorageImpl(container.getProvider("app").getImmediate(), container.getProvider("auth-internal"), container.getProvider("app-check-internal"), url, SDK_VERSION);
}
function registerStorage() {
	_registerComponent(new Component(STORAGE_TYPE, factory, "PUBLIC").setMultipleInstances(true));
	registerVersion(name, version, "");
	registerVersion(name, version, "esm2020");
}
registerStorage();

//#endregion
export { StorageError, StorageErrorCode, StringFormat, FbsBlob as _FbsBlob, Location as _Location, TaskEvent as _TaskEvent, TaskState as _TaskState, UploadTask as _UploadTask, dataFromString as _dataFromString, _getChild, invalidArgument as _invalidArgument, invalidRootOperation as _invalidRootOperation, connectStorageEmulator, deleteObject, getBlob, getBytes, getDownloadURL, getMetadata, getStorage, getStream, list, listAll, ref, updateMetadata, uploadBytes, uploadBytesResumable, uploadString };
//# sourceMappingURL=firebase_storage.js.map